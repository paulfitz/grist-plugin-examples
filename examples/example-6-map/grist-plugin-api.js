var grist =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/plugin/grist-plugin-api.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/plugin/CustomSectionAPI-ti.ts":
/*!*******************************************!*\
  !*** ./app/plugin/CustomSectionAPI-ti.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.CustomSectionAPI = t.iface([], {\n    \"createSection\": t.func(\"void\", t.param(\"inlineTarget\", \"RenderTarget\")),\n});\nconst exportedTypeSuite = {\n    CustomSectionAPI: exports.CustomSectionAPI,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/CustomSectionAPI-ti.ts?");

/***/ }),

/***/ "./app/plugin/FileParserAPI-ti.ts":
/*!****************************************!*\
  !*** ./app/plugin/FileParserAPI-ti.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.EditOptionsAPI = t.iface([], {\n    \"getParseOptions\": t.func(\"ParseOptions\", t.param(\"parseOptions\", \"ParseOptions\", true)),\n});\nexports.ParseFileAPI = t.iface([], {\n    \"parseFile\": t.func(\"ParseFileResult\", t.param(\"file\", \"FileSource\"), t.param(\"parseOptions\", \"ParseOptions\", true)),\n});\nexports.ParseOptions = t.iface([], {\n    \"NUM_ROWS\": t.opt(\"number\"),\n    \"SCHEMA\": t.opt(t.array(\"ParseOptionSchema\")),\n});\nexports.ParseOptionSchema = t.iface([], {\n    \"name\": \"string\",\n    \"label\": \"string\",\n    \"type\": \"string\",\n    \"visible\": \"boolean\",\n});\nexports.FileSource = t.iface([], {\n    \"path\": \"string\",\n    \"origName\": \"string\",\n});\nexports.ParseFileResult = t.iface([\"GristTables\"], {\n    \"parseOptions\": \"ParseOptions\",\n});\nconst exportedTypeSuite = {\n    EditOptionsAPI: exports.EditOptionsAPI,\n    ParseFileAPI: exports.ParseFileAPI,\n    ParseOptions: exports.ParseOptions,\n    ParseOptionSchema: exports.ParseOptionSchema,\n    FileSource: exports.FileSource,\n    ParseFileResult: exports.ParseFileResult,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/FileParserAPI-ti.ts?");

/***/ }),

/***/ "./app/plugin/FileParserAPI.ts":
/*!*************************************!*\
  !*** ./app/plugin/FileParserAPI.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * API definitions for FileParser plugins.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack://grist/./app/plugin/FileParserAPI.ts?");

/***/ }),

/***/ "./app/plugin/GristAPI-ti.ts":
/*!***********************************!*\
  !*** ./app/plugin/GristAPI-ti.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.ComponentKind = t.union(t.lit(\"safeBrowser\"), t.lit(\"safePython\"), t.lit(\"unsafeNode\"));\nexports.GristAPI = t.iface([], {\n    \"render\": t.func(\"number\", t.param(\"path\", \"string\"), t.param(\"target\", \"RenderTarget\"), t.param(\"options\", \"RenderOptions\", true)),\n    \"dispose\": t.func(\"void\", t.param(\"procId\", \"number\")),\n    \"subscribe\": t.func(\"void\", t.param(\"tableId\", \"string\")),\n    \"unsubscribe\": t.func(\"void\", t.param(\"tableId\", \"string\")),\n});\nexports.GristDocAPI = t.iface([], {\n    \"getDocName\": t.func(\"string\"),\n    \"listTables\": t.func(t.array(\"string\")),\n    \"fetchTable\": t.func(\"any\", t.param(\"tableId\", \"string\")),\n    \"applyUserActions\": t.func(\"any\", t.param(\"actions\", t.array(t.array(\"any\")))),\n});\nconst exportedTypeSuite = {\n    ComponentKind: exports.ComponentKind,\n    GristAPI: exports.GristAPI,\n    GristDocAPI: exports.GristDocAPI,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/GristAPI-ti.ts?");

/***/ }),

/***/ "./app/plugin/GristAPI.ts":
/*!********************************!*\
  !*** ./app/plugin/GristAPI.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * This file defines the interface for the grist api exposed to SafeBrowser plugins. Grist supports\n * various ways to require it to cover various scenarios. If writing the main safeBrowser module\n * (the one referenced by the components.safeBrowser key of the manifest) use\n * `self.importScript('grist');`, if writing a view include the script in the html `<script src=\"grist\"></script>`\n *\n *\n * Example usage (let's assume that Grist let's plugin contributes to a Foo API defined as follow ):\n *\n * interface Foo {\n *   foo(name: string): Promise<string>;\n * }\n *\n * > main.ts:\n * class MyFoo {\n *   public foo(name: string): Promise<string> {\n *     return new Promise<string>( async resolve => {\n *       grist.rpc.onMessage( e => {\n *         resolve(e.data + name);\n *       });\n *       grist.ready();\n *       await grist.api.render('view1.html', 'fullscreen');\n *     });\n *   }\n * }\n * grist.rpc.registerImpl<Foo>('grist', new MyFoo()); // can add 3rd arg with type information\n *\n * > view1.html includes:\n * grist.api.render('static/view2.html', 'fullscreen').then( view => {\n *   grist.rpc.onMessage(e => grist.rpc.postMessageForward(\"main.ts\", e.data));\n * });\n *\n * > view2.html includes:\n * grist.rpc.postMessage('view1.html', 'foo ');\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RPC_GRISTAPI_INTERFACE = '_grist_api';\n\n\n//# sourceURL=webpack://grist/./app/plugin/GristAPI.ts?");

/***/ }),

/***/ "./app/plugin/GristTable-ti.ts":
/*!*************************************!*\
  !*** ./app/plugin/GristTable-ti.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.GristTable = t.iface([], {\n    \"table_name\": t.union(\"string\", \"null\"),\n    \"column_metadata\": t.array(\"GristColumn\"),\n    \"table_data\": t.array(t.array(\"any\")),\n});\nexports.GristTables = t.iface([], {\n    \"tables\": t.array(\"GristTable\"),\n});\nexports.GristColumn = t.iface([], {\n    \"id\": \"string\",\n    \"type\": \"string\",\n});\nconst exportedTypeSuite = {\n    GristTable: exports.GristTable,\n    GristTables: exports.GristTables,\n    GristColumn: exports.GristColumn,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/GristTable-ti.ts?");

/***/ }),

/***/ "./app/plugin/GristTable.ts":
/*!**********************************!*\
  !*** ./app/plugin/GristTable.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Common definitions for Grist plugin APIs.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar APIType;\n(function (APIType) {\n    APIType[APIType[\"ImportSourceAPI\"] = 0] = \"ImportSourceAPI\";\n    APIType[APIType[\"ImportProcessorAPI\"] = 1] = \"ImportProcessorAPI\";\n    APIType[APIType[\"ParseOptionsAPI\"] = 2] = \"ParseOptionsAPI\";\n    APIType[APIType[\"ParseFileAPI\"] = 3] = \"ParseFileAPI\";\n})(APIType = exports.APIType || (exports.APIType = {}));\n\n\n//# sourceURL=webpack://grist/./app/plugin/GristTable.ts?");

/***/ }),

/***/ "./app/plugin/ImportSourceAPI-ti.ts":
/*!******************************************!*\
  !*** ./app/plugin/ImportSourceAPI-ti.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.ImportSourceAPI = t.iface([], {\n    \"getImportSource\": t.func(t.union(\"ImportSource\", \"undefined\")),\n});\nexports.ImportProcessorAPI = t.iface([], {\n    \"processImport\": t.func(t.array(\"GristTable\"), t.param(\"source\", \"ImportSource\")),\n});\nexports.FileContent = t.iface([], {\n    \"content\": \"any\",\n    \"name\": \"string\",\n});\nexports.FileListItem = t.iface([], {\n    \"kind\": t.lit(\"fileList\"),\n    \"files\": t.array(\"FileContent\"),\n});\nexports.URL = t.iface([], {\n    \"kind\": t.lit(\"url\"),\n    \"url\": \"string\",\n});\nexports.ImportSource = t.iface([], {\n    \"item\": t.union(\"FileListItem\", \"URL\"),\n    \"options\": t.opt(t.union(\"string\", \"Buffer\")),\n    \"description\": t.opt(\"string\"),\n});\nconst exportedTypeSuite = {\n    ImportSourceAPI: exports.ImportSourceAPI,\n    ImportProcessorAPI: exports.ImportProcessorAPI,\n    FileContent: exports.FileContent,\n    FileListItem: exports.FileListItem,\n    URL: exports.URL,\n    ImportSource: exports.ImportSource,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/ImportSourceAPI-ti.ts?");

/***/ }),

/***/ "./app/plugin/ImportSourceAPI.ts":
/*!***************************************!*\
  !*** ./app/plugin/ImportSourceAPI.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * API definitions for ImportSource plugins.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack://grist/./app/plugin/ImportSourceAPI.ts?");

/***/ }),

/***/ "./app/plugin/InternalImportSourceAPI-ti.ts":
/*!**************************************************!*\
  !*** ./app/plugin/InternalImportSourceAPI-ti.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.InternalImportSourceAPI = t.iface([], {\n    \"getImportSource\": t.func(t.union(\"ImportSource\", \"undefined\"), t.param(\"inlineTarget\", \"RenderTarget\")),\n});\nconst exportedTypeSuite = {\n    InternalImportSourceAPI: exports.InternalImportSourceAPI,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/InternalImportSourceAPI-ti.ts?");

/***/ }),

/***/ "./app/plugin/RenderOptions-ti.ts":
/*!****************************************!*\
  !*** ./app/plugin/RenderOptions-ti.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.RenderTarget = t.union(t.lit(\"fullscreen\"), \"number\");\nexports.RenderOptions = t.iface([], {\n    \"height\": t.opt(\"string\"),\n});\nconst exportedTypeSuite = {\n    RenderTarget: exports.RenderTarget,\n    RenderOptions: exports.RenderOptions,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/RenderOptions-ti.ts?");

/***/ }),

/***/ "./app/plugin/RenderOptions.ts":
/*!*************************************!*\
  !*** ./app/plugin/RenderOptions.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack://grist/./app/plugin/RenderOptions.ts?");

/***/ }),

/***/ "./app/plugin/StorageAPI-ti.ts":
/*!*************************************!*\
  !*** ./app/plugin/StorageAPI-ti.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.Storage = t.iface([], {\n    \"getItem\": t.func(\"any\", t.param(\"key\", \"string\")),\n    \"hasItem\": t.func(\"boolean\", t.param(\"key\", \"string\")),\n    \"setItem\": t.func(\"void\", t.param(\"key\", \"string\"), t.param(\"value\", \"any\")),\n    \"removeItem\": t.func(\"void\", t.param(\"key\", \"string\")),\n    \"clear\": t.func(\"void\"),\n});\nconst exportedTypeSuite = {\n    Storage: exports.Storage,\n};\nexports.default = exportedTypeSuite;\n\n\n//# sourceURL=webpack://grist/./app/plugin/StorageAPI-ti.ts?");

/***/ }),

/***/ "./app/plugin/StorageAPI.ts":
/*!**********************************!*\
  !*** ./app/plugin/StorageAPI.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack://grist/./app/plugin/StorageAPI.ts?");

/***/ }),

/***/ "./app/plugin/TypeCheckers.ts":
/*!************************************!*\
  !*** ./app/plugin/TypeCheckers.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ts_interface_checker_1 = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\nconst CustomSectionAPI_ti_1 = __webpack_require__(/*! ./CustomSectionAPI-ti */ \"./app/plugin/CustomSectionAPI-ti.ts\");\nexports.CustomSectionAPITI = CustomSectionAPI_ti_1.default;\nconst FileParserAPI_ti_1 = __webpack_require__(/*! ./FileParserAPI-ti */ \"./app/plugin/FileParserAPI-ti.ts\");\nexports.FileParserAPITI = FileParserAPI_ti_1.default;\nconst GristAPI_ti_1 = __webpack_require__(/*! ./GristAPI-ti */ \"./app/plugin/GristAPI-ti.ts\");\nexports.GristAPITI = GristAPI_ti_1.default;\nconst GristTable_ti_1 = __webpack_require__(/*! ./GristTable-ti */ \"./app/plugin/GristTable-ti.ts\");\nexports.GristTableTI = GristTable_ti_1.default;\nconst ImportSourceAPI_ti_1 = __webpack_require__(/*! ./ImportSourceAPI-ti */ \"./app/plugin/ImportSourceAPI-ti.ts\");\nexports.ImportSourceAPITI = ImportSourceAPI_ti_1.default;\nconst InternalImportSourceAPI_ti_1 = __webpack_require__(/*! ./InternalImportSourceAPI-ti */ \"./app/plugin/InternalImportSourceAPI-ti.ts\");\nexports.InternalImportSourceAPITI = InternalImportSourceAPI_ti_1.default;\nconst RenderOptions_ti_1 = __webpack_require__(/*! ./RenderOptions-ti */ \"./app/plugin/RenderOptions-ti.ts\");\nexports.RenderOptionsTI = RenderOptions_ti_1.default;\nconst StorageAPI_ti_1 = __webpack_require__(/*! ./StorageAPI-ti */ \"./app/plugin/StorageAPI-ti.ts\");\nexports.StorageAPITI = StorageAPI_ti_1.default;\nconst allTypes = [\n    CustomSectionAPI_ti_1.default, FileParserAPI_ti_1.default, GristAPI_ti_1.default, GristTable_ti_1.default, ImportSourceAPI_ti_1.default,\n    InternalImportSourceAPI_ti_1.default, RenderOptions_ti_1.default, StorageAPI_ti_1.default\n];\nfunction checkDuplicates(types) {\n    const seen = new Set();\n    for (const t of types) {\n        for (const key of Object.keys(t)) {\n            if (seen.has(key)) {\n                throw new Error(`TypeCheckers: Duplicate type name ${key}`);\n            }\n            seen.add(key);\n            // Uncomment the line below to generate updated list of included types.\n            // console.log(`'${key}' |`);\n        }\n    }\n}\ncheckDuplicates(allTypes);\n/**\n * We also create and export a global checker object that includes all of the types above.\n */\nexports.checkers = ts_interface_checker_1.createCheckers(...allTypes);\n\n\n//# sourceURL=webpack://grist/./app/plugin/TypeCheckers.ts?");

/***/ }),

/***/ "./app/plugin/grist-plugin-api.ts":
/*!****************************************!*\
  !*** ./app/plugin/grist-plugin-api.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Provide a way to acess grist for iframe, web worker (which runs the main safeBrowser script) and\n// unsafeNode. WebView should work the same way as iframe, grist is exposed just the same way and\n// necessary api is exposed using preload script. Here we bootstrap from channel capabilities to key\n// parts of the grist API.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// For iframe (and webview):\n// user will add '<script src=\"/grist-api.js\"></script>' and get a window.grist\n// For web worker:\n// use will add `self.importScripts('/grist-api.js');`\n// For node, user will do something like:\n//   const {grist} = require('grist-api');\n//   grist.registerFunction();\n// In TypeScript:\n//   import {grist} from 'grist-api';\n//   grist.registerFunction();\n// tslint:disable:no-console\nconst GristAPI_1 = __webpack_require__(/*! ./GristAPI */ \"./app/plugin/GristAPI.ts\");\nconst TypeCheckers_1 = __webpack_require__(/*! ./TypeCheckers */ \"./app/plugin/TypeCheckers.ts\");\n__export(__webpack_require__(/*! ./TypeCheckers */ \"./app/plugin/TypeCheckers.ts\"));\n__export(__webpack_require__(/*! ./FileParserAPI */ \"./app/plugin/FileParserAPI.ts\"));\n__export(__webpack_require__(/*! ./GristAPI */ \"./app/plugin/GristAPI.ts\"));\n__export(__webpack_require__(/*! ./GristTable */ \"./app/plugin/GristTable.ts\"));\n__export(__webpack_require__(/*! ./ImportSourceAPI */ \"./app/plugin/ImportSourceAPI.ts\"));\n__export(__webpack_require__(/*! ./StorageAPI */ \"./app/plugin/StorageAPI.ts\"));\n__export(__webpack_require__(/*! ./RenderOptions */ \"./app/plugin/RenderOptions.ts\"));\nconst grain_rpc_1 = __webpack_require__(/*! grain-rpc */ \"./node_modules/grain-rpc/dist/lib/index.js\");\nexports.rpc = new grain_rpc_1.Rpc({ logger: createRpcLogger() });\nexports.api = exports.rpc.getStub(GristAPI_1.RPC_GRISTAPI_INTERFACE, TypeCheckers_1.checkers.GristAPI);\nexports.docApi = exports.rpc.getStub('GristDocAPI@grist', TypeCheckers_1.checkers.GristDocAPI);\n/**\n * Calling `addImporter(...)` adds a safeBrowser importer. It is a short-hand for forwarding calls\n * to an `ImportSourceAPI` implementation registered in the file at `path`. It takes care of\n * creating the stub, registering an implementation that renders the file, forward the call and\n * dispose the view properly. If `mode` is `'inline'` embeds the view in the import modal, ohterwise\n * renders fullscreen.\n *\n * Notes: it assumes that file at `path` registers an `ImportSourceAPI` implementation under\n * `name`. Calling `addImporter(...)` from another component than a `safeBrowser` component is not\n * currently supported.\n *\n */\nfunction addImporter(name, path, mode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // checker is omitterd for implementation because call was alredy checked by grist.\n        exports.rpc.registerImpl(name, {\n            getImportSource(target) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    const procId = yield exports.api.render(path, mode === 'inline' ? target : 'fullscreen');\n                    try {\n                        // stubName for the interface `name` at forward destination `path`\n                        const stubName = `${name}@${path}`;\n                        // checker is omitted in stub because call will be checked just after in grist.\n                        return yield exports.rpc.getStub(stubName).getImportSource();\n                    }\n                    finally {\n                        yield exports.api.dispose(procId);\n                    }\n                });\n            }\n        });\n    });\n}\nexports.addImporter = addImporter;\n/**\n * Declare that a component is prepared to receive messages from the outside world.\n * Grist will not attempt to communicate with it until this method is called.\n */\nfunction ready() {\n    exports.rpc.processIncoming();\n    exports.rpc.sendReadyMessage();\n}\nexports.ready = ready;\nfunction getPluginPath(location) {\n    return location.pathname.replace(/^\\/plugins\\//, '');\n}\nif (typeof window !== 'undefined') {\n    // Window or iframe.\n    const preloadWindow = window;\n    if (preloadWindow.isRunningUnderElectron) {\n        exports.rpc.setSendMessage(msg => preloadWindow.sendToHost(msg));\n        preloadWindow.onGristMessage((data) => exports.rpc.receiveMessage(data));\n    }\n    else {\n        exports.rpc.setSendMessage(msg => window.parent.postMessage(msg, \"*\"));\n        window.onmessage = (e) => exports.rpc.receiveMessage(e.data);\n    }\n}\nelse if (typeof process === 'undefined') {\n    // Web worker. We can't really bring in the types for WebWorker (available with --lib flag)\n    // without conflicting with a regular window, so use just use `self as any` here.\n    self.onmessage = (e) => exports.rpc.receiveMessage(e.data);\n    exports.rpc.setSendMessage((mssg) => self.postMessage(mssg));\n}\nelse if (typeof process.send !== 'undefined') {\n    // Forked ChildProcess of node or electron.\n    // sendMessage callback returns void 0 because rpc process.send returns a boolean and rpc\n    // expecting void|Promise interprets truthy values as Promise which cause failure.\n    exports.rpc.setSendMessage((data) => { process.send(data); });\n    process.on('message', (data) => exports.rpc.receiveMessage(data));\n    process.on('disconnect', () => { process.exit(0); });\n}\nelse {\n    // Not a recognized environment, perhaps plain nodejs run independently of Grist, or tests\n    // running under mocha. For now, we only provide a disfunctional implementation. It allows\n    // plugins to call methods like registerFunction() without failing, so that plugin code may be\n    // imported, but the methods don't do anything useful.\n    exports.rpc.setSendMessage((data) => { return; });\n}\nfunction createRpcLogger() {\n    let prefix;\n    if (typeof window !== 'undefined') {\n        prefix = `PLUGIN VIEW ${getPluginPath(window.location)}:`;\n    }\n    else if (typeof process === 'undefined') {\n        prefix = `PLUGIN VIEW ${getPluginPath(self.location)}:`;\n    }\n    else if (typeof process.send !== 'undefined') {\n        prefix = `PLUGIN NODE ${process.env.GRIST_PLUGIN_PATH || \"<unset-plugin-id>\"}:`;\n    }\n    else {\n        return {};\n    }\n    return {\n        info(msg) { console.log(\"%s %s\", prefix, msg); },\n        warn(msg) { console.warn(\"%s %s\", prefix, msg); },\n    };\n}\n\n\n//# sourceURL=webpack://grist/./app/plugin/grist-plugin-api.ts?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://grist/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/grain-rpc/dist/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/grain-rpc/dist/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./message */ \"./node_modules/grain-rpc/dist/lib/message.js\"));\n__export(__webpack_require__(/*! ./rpc */ \"./node_modules/grain-rpc/dist/lib/rpc.js\"));\n\n\n//# sourceURL=webpack://grist/./node_modules/grain-rpc/dist/lib/index.js?");

/***/ }),

/***/ "./node_modules/grain-rpc/dist/lib/message.js":
/*!****************************************************!*\
  !*** ./node_modules/grain-rpc/dist/lib/message.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * This defines the message types sent over an RpcChannel.\n *\n * WARNING: Any changes to these must be backward-compatible, since Rpc may be used across\n * different versions of this library. Specifically, enums must not be renumbered, fields renamed,\n * or their types changed. Really, the only reasonable enhancement is adding a new optional field.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MsgType;\n(function (MsgType) {\n    // Warning: Do NOT renumber enums (see warning above).\n    MsgType[MsgType[\"RpcCall\"] = 1] = \"RpcCall\";\n    MsgType[MsgType[\"RpcRespData\"] = 2] = \"RpcRespData\";\n    MsgType[MsgType[\"RpcRespErr\"] = 3] = \"RpcRespErr\";\n    MsgType[MsgType[\"Custom\"] = 4] = \"Custom\";\n    MsgType[MsgType[\"Ready\"] = 5] = \"Ready\";\n})(MsgType = exports.MsgType || (exports.MsgType = {}));\n\n\n//# sourceURL=webpack://grist/./node_modules/grain-rpc/dist/lib/message.js?");

/***/ }),

/***/ "./node_modules/grain-rpc/dist/lib/rpc.js":
/*!************************************************!*\
  !*** ./node_modules/grain-rpc/dist/lib/rpc.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Rpc implements an remote-procedure-call interface on top of a simple messaging interface.\n *\n * The user must provide the messaging between two endpoints, and in return gets the ability to\n * register interfaces or functions at either endpoint, and call them from the other side. For\n * messaging, the user must supply a sendMessage() function to send messages to the other side,\n * and must call rpc.receiveMessage(msg) whenever a message is received.\n *\n * E.g.\n *    rpc.registerImpl<MyInterface>(\"some-name\", new MyInterfaceImpl(), descMyInterfaceImpl);\n *    rpc.getStub<MyInterface>(\"some-name\", descMyInterfaceImpl)\n *          => returns a stub implemeting MyInterface\n *\n * Calls to the generated stub get turned into messages across the channel, and then call to the\n * implementation object registered on the other side. Both return values and exceptions get\n * passed back over the channel, and cause the promise from the stub to be resolved or rejected.\n *\n * Note that the stub interface returns Promises for all methods.\n *\n * Rpc library supports ts-interface-checker descriptors for the interfaces, to allow validation.\n * You may skip it by passing in `rpc.unchecked` where a descriptor is expected; it will skip\n * checks and you will not get descriptive errors.\n *\n * The string name used to register and use an implementation allows for the same Rpc object to be\n * used to expose multiple interfaces, or different implementations of the same interface.\n *\n * Messaging\n * ---------\n * Rpc also supports a messaging interface, with postMessage() to send arbitrary messages, and an\n * EventEmitter interface for \"message\" events to receive them, e.g. on(\"message\", ...). So if you\n * need to multiplex non-Rpc messages over the same channel, Rpc class does it for you.\n *\n * Cleanup\n * -------\n * If the channel is closed or had an error, and will no longer be used, the user of Rpc must\n * call rpc.close() to reject any calls waiting for an answer.\n *\n * If a particular stub for a remote API is no longer needed, user may call rpc.discardStub(stub)\n * to reject any pending calls made to that stub.\n *\n * Timeouts\n * --------\n * TODO (Not yet implementd.)\n * You may call rpc.setTimeout(ms) or rpc.setStubTimeout(stub, ms) to set a call timeout for all\n * stubs or for a particular one. If a response to a call does not arrive within the timeout, the\n * call gets rejected, and the rejection Error will have a \"code\" property set to \"TIMEOUT\".\n *\n * Forwarding\n * ----------\n * Rpc.registerForwarder() along with methods with \"-Forward\" suffix allow one Rpc object to forward\n * calls and messages to another Rpc object. The intended usage is when Rpc connects A to B, and B\n * to C. Then B can use registerForwarder to expose A's interfaces to C (or C's to A) without having\n * to know what exactly they are. A default forwarder can be registered using the '*' name.\n *\n *\n * Instead of using getStubForward and callRemoteFuncForward, the forwarder name can be\n * appended to the interface name as \"interfaceName@forwarderName\" and the regular\n * getStub and callRemoteFunc methods can be used.  For example:\n *   getStub(\"iface@forwarder\")\n * is the same as:\n *   getStubForward(\"forwarder\", \"iface\")\n *\n *\n * E.g. with A.registerImpl(\"A-name\", ...) and B.registerForwarder(\"b2a\", A), we may now call\n * C.getStubForward(\"b2a\", \"A-name\") to get a stub that will forward calls to A, as well as\n * C.postMessageForward(\"b2a\", msg) to have the message received by A.\n *\n * TODO We may want to support progress callbacks, perhaps by supporting arbitrary callbacks as\n * parameters. (Could be implemented by allowing \"meth\" to be [reqId, paramPath]) It would be nice\n * to allow the channel to report progress too, e.g. to report progress of uploading large files.\n *\n * TODO Sending of large files should probably be a separate feature, to allow for channel\n * implementations to stream them.\n */\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst tic = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\nconst message_1 = __webpack_require__(/*! ./message */ \"./node_modules/grain-rpc/dist/lib/message.js\");\nconst plainCall = (callFunc) => callFunc();\nclass Rpc extends events_1.EventEmitter {\n    /**\n     * To use Rpc, you must provide a sendMessage function that sends a message to the other side;\n     * it may be given in the constructor, or later with setSendMessage. You must also call\n     * receiveMessage() for every message received from the other side.\n     */\n    constructor(options = {}) {\n        super();\n        // Note the invariant: _inactiveSendQueue == null iff (_sendMessageCB != null && !_waitForReadyMessage)\n        this._sendMessageCB = null;\n        this._inactiveRecvQueue = null; // queue of received message\n        this._inactiveSendQueue = null; // queue of messages to be sent\n        this._waitForReadyMessage = false;\n        this._implMap = new Map();\n        this._forwarders = new Map();\n        this._pendingCalls = new Map();\n        this._nextRequestId = 1;\n        const { logger = console, sendMessage = null, callWrapper = plainCall } = options;\n        this._logger = logger;\n        this._callWrapper = callWrapper;\n        this.setSendMessage(sendMessage);\n    }\n    /**\n     * To use Rpc, call this for every message received from the other side of the channel.\n     */\n    receiveMessage(msg) {\n        if (this._inactiveRecvQueue) {\n            this._inactiveRecvQueue.push(msg);\n        }\n        else {\n            this._dispatch(msg);\n        }\n    }\n    /**\n     * If you've set up calls to receiveMessage(), but need time to call registerImpl() before\n     * processing new messages, you may use queueIncoming(), make the registerImpl() calls,\n     * and then call processIncoming() to handle queued messages and resume normal processing.\n     */\n    queueIncoming() {\n        if (!this._inactiveRecvQueue) {\n            this._inactiveRecvQueue = [];\n        }\n    }\n    /**\n     * Process received messages queued since queueIncoming, and resume normal processing of\n     * received messages.\n     */\n    processIncoming() {\n        if (this._inactiveRecvQueue) {\n            processQueue(this._inactiveRecvQueue, this._dispatch.bind(this));\n            this._inactiveRecvQueue = null;\n        }\n    }\n    /**\n     * Set the callback to send messages. If set to null, sent messages will be queued. If you\n     * disconnect and want for sent messages to throw, set a callback that throws.\n     */\n    setSendMessage(sendMessage) {\n        this._sendMessageCB = sendMessage;\n        if (this._sendMessageCB) {\n            this._processOutgoing();\n        }\n        else {\n            this._queueOutgoing();\n        }\n    }\n    /**\n     * If your peer may not be listening yet to your messages, you may call this to queue outgoing\n     * messages until receiving a \"ready\" message from the peer. I.e. one peer may call\n     * queueOutgoingUntilReadyMessage() while the other calls sendReadyMessage().\n     */\n    queueOutgoingUntilReadyMessage() {\n        this._waitForReadyMessage = true;\n        this._queueOutgoing();\n    }\n    /**\n     * If your peer is using queueOutgoingUntilReadyMessage(), you should let it know that you are\n     * ready using sendReadyMessage() as soon as you've set up the processing of received messages.\n     * Note that at most one peer may use queueOutgoingUntilReadyMessage(), or they will deadlock.\n     */\n    sendReadyMessage() {\n        return this._sendMessage({ mtype: message_1.MsgType.Ready });\n    }\n    /**\n     * Messaging interface: send data to the other side, to be emitted there as a \"message\" event.\n     */\n    postMessage(data) { return this.postMessageForward(\"\", data); }\n    postMessageForward(fwdDest, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const msg = { mtype: message_1.MsgType.Custom, data };\n            if (fwdDest) {\n                msg.mdest = fwdDest;\n            }\n            yield this._sendMessage(msg);\n        });\n    }\n    registerImpl(name, impl, checker) {\n        if (this._implMap.has(name)) {\n            throw new Error(`Rpc.registerImpl has already been called for ${name}`);\n        }\n        const invokeImpl = (call) => impl[call.meth](...call.args);\n        if (!checker) {\n            this._implMap.set(name, { name, invokeImpl, argsCheckers: null });\n        }\n        else {\n            const ttype = checker.getType();\n            if (!(ttype instanceof tic.TIface)) {\n                throw new Error(\"Rpc.registerImpl requires a Checker for an interface\");\n            }\n            const argsCheckers = {};\n            for (const prop of ttype.props) {\n                if (prop.ttype instanceof tic.TFunc) {\n                    argsCheckers[prop.name] = checker.methodArgs(prop.name);\n                }\n            }\n            this._implMap.set(name, { name, invokeImpl, argsCheckers });\n        }\n    }\n    registerForwarder(fwdName, dest, fwdDest = (fwdName === \"*\" ? \"*\" : \"\")) {\n        const passThru = fwdDest === \"*\";\n        this._forwarders.set(fwdName, {\n            name: \"[FWD]\" + fwdName,\n            argsCheckers: null,\n            invokeImpl: (c) => dest.forwardCall(Object.assign({}, c, { mdest: passThru ? c.mdest : fwdDest })),\n            forwardMessage: (msg) => dest.forwardMessage(Object.assign({}, msg, { mdest: passThru ? msg.mdest : fwdDest })),\n        });\n    }\n    unregisterForwarder(fwdName) {\n        this._forwarders.delete(fwdName);\n    }\n    /**\n     * Unregister an implementation, if one was registered with this name.\n     */\n    unregisterImpl(name) {\n        this._implMap.delete(name);\n    }\n    getStub(name, checker) {\n        const parts = this._parseName(name);\n        return this.getStubForward(parts.forwarder, parts.name, checker);\n    }\n    getStubForward(fwdDest, name, checker) {\n        if (!checker) {\n            // TODO Test, then explain how this works.\n            return new Proxy({}, {\n                get: (target, property, receiver) => {\n                    if (property === \"then\") {\n                        // By default, take care not to look \"thenable\", so that the stub can be returned\n                        // as a value of a Promise:\n                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\n                        // If user really wants to proxy \"then\", they can write a checker.\n                        return undefined;\n                    }\n                    return (...args) => this._makeCall(name, property, args, anyChecker, fwdDest);\n                },\n            });\n        }\n        else {\n            const ttype = checker.getType();\n            if (!(ttype instanceof tic.TIface)) {\n                throw new Error(\"Rpc.getStub requires a Checker for an interface\");\n            }\n            const api = {};\n            for (const prop of ttype.props) {\n                if (prop.ttype instanceof tic.TFunc) {\n                    const resultChecker = checker.methodResult(prop.name);\n                    api[prop.name] = (...args) => this._makeCall(name, prop.name, args, resultChecker, fwdDest);\n                }\n            }\n            return api;\n        }\n    }\n    /**\n     * Simple way to registers a function under a given name, with no argument checking.\n     */\n    registerFunc(name, impl) {\n        return this.registerImpl(name, { invoke: impl }, checkerAnyFunc);\n    }\n    /**\n     * Unregister a function, if one was registered with this name.\n     */\n    unregisterFunc(name) {\n        return this.unregisterImpl(name);\n    }\n    /**\n     * Call a remote function registered with registerFunc. Does no type checking.\n     */\n    callRemoteFunc(name, ...args) {\n        const parts = this._parseName(name);\n        return this.callRemoteFuncForward(parts.forwarder, parts.name, ...args);\n    }\n    callRemoteFuncForward(fwdDest, name, ...args) {\n        return this._makeCall(name, \"invoke\", args, anyChecker, fwdDest);\n    }\n    forwardCall(c) {\n        return this._makeCall(c.iface, c.meth, c.args, anyChecker, c.mdest || \"\");\n    }\n    forwardMessage(msg) {\n        return this.postMessageForward(msg.mdest || \"\", msg.data);\n    }\n    // Mark outgoing messages for queueing.\n    _queueOutgoing() {\n        if (!this._inactiveSendQueue) {\n            this._inactiveSendQueue = [];\n        }\n    }\n    // If sendMessageCB is set and we are no longer waiting for a ready message, send out any\n    // queued outgoing messages and resume normal sending.\n    _processOutgoing() {\n        if (this._inactiveSendQueue && this._sendMessageCB && !this._waitForReadyMessage) {\n            processQueue(this._inactiveSendQueue, this._sendMessageOrReject.bind(this, this._sendMessageCB));\n            this._inactiveSendQueue = null;\n        }\n    }\n    _sendMessage(msg) {\n        if (this._inactiveSendQueue) {\n            this._inactiveSendQueue.push(msg);\n        }\n        else {\n            return this._sendMessageOrReject(this._sendMessageCB, msg);\n        }\n    }\n    // This helper calls calls sendMessage(msg), and if that call fails, rejects the call\n    // represented by msg (when it's of type RpcCall).\n    _sendMessageOrReject(sendMessage, msg) {\n        if (this._logger.info) {\n            const desc = (msg.mtype === message_1.MsgType.RpcCall) ? \": \" + this._callDesc(msg) : \"\";\n            this._logger.info(`Rpc sending ${message_1.MsgType[msg.mtype]}${desc}`);\n        }\n        return catchMaybePromise(() => sendMessage(msg), (err) => this._sendReject(msg, err));\n    }\n    // Rejects a RpcCall due to the given send error; this helper always re-throws.\n    _sendReject(msg, err) {\n        const newErr = new ErrorWithCode(\"RPC_SEND_FAILED\", `Send failed: ${err.message}`);\n        if (msg.mtype === message_1.MsgType.RpcCall && msg.reqId !== undefined) {\n            const callObj = this._pendingCalls.get(msg.reqId);\n            if (callObj) {\n                this._pendingCalls.delete(msg.reqId);\n                callObj.reject(newErr);\n            }\n        }\n        this.emit(\"error\", newErr);\n        throw newErr;\n    }\n    _makeCallRaw(iface, meth, args, resultChecker, fwdDest) {\n        return new Promise((resolve, reject) => {\n            const reqId = this._nextRequestId++;\n            const callObj = { reqId, iface, meth, resolve, reject, resultChecker };\n            this._pendingCalls.set(reqId, callObj);\n            // Send the Call message. If the sending fails, reject the _makeCall promise. If it\n            // succeeds, we save {resolve,reject} to resolve _makeCall when we get back a response.\n            this._info(callObj, \"RPC_CALLING\");\n            const msg = { mtype: message_1.MsgType.RpcCall, reqId, iface, meth, args };\n            if (fwdDest) {\n                msg.mdest = fwdDest;\n            }\n            // If _sendMessage fails, reject, allowing it to throw synchronously or not.\n            catchMaybePromise(() => this._sendMessage(msg), reject);\n        });\n    }\n    _makeCall(iface, meth, args, resultChecker, fwdDest) {\n        return this._callWrapper(() => this._makeCallRaw(iface, meth, args, resultChecker, fwdDest));\n    }\n    _dispatch(msg) {\n        switch (msg.mtype) {\n            case message_1.MsgType.RpcCall: {\n                this._onMessageCall(msg);\n                return;\n            }\n            case message_1.MsgType.RpcRespData:\n            case message_1.MsgType.RpcRespErr: {\n                this._onMessageResp(msg);\n                return;\n            }\n            case message_1.MsgType.Custom: {\n                this._onCustomMessage(msg);\n                return;\n            }\n            case message_1.MsgType.Ready: {\n                this._waitForReadyMessage = false;\n                try {\n                    this._processOutgoing();\n                }\n                catch (e) { /* swallowing error, an event 'error' was already emitted */ }\n                return;\n            }\n        }\n    }\n    _onCustomMessage(msg) {\n        if (msg.mdest) {\n            const impl = this._forwarders.get(msg.mdest) || this._forwarders.get(\"*\");\n            if (!impl) {\n                this._warn(null, \"RPC_UNKNOWN_FORWARD_DEST\", \"Unknown forward destination\");\n            }\n            else {\n                impl.forwardMessage(msg);\n            }\n        }\n        else {\n            this.emit(\"message\", msg.data);\n        }\n    }\n    _onMessageCall(call) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let impl;\n            if (call.mdest) {\n                impl = this._forwarders.get(call.mdest) || this._forwarders.get(\"*\");\n                if (!impl) {\n                    return this._failCall(call, \"RPC_UNKNOWN_FORWARD_DEST\", \"Unknown forward destination\");\n                }\n            }\n            else {\n                impl = this._implMap.get(call.iface);\n                if (!impl) {\n                    return this._failCall(call, \"RPC_UNKNOWN_INTERFACE\", \"Unknown interface\");\n                }\n            }\n            if (!impl.argsCheckers) {\n                // No call or argument checking.\n            }\n            else {\n                // Check the method name and argument types.\n                if (!impl.argsCheckers.hasOwnProperty(call.meth)) {\n                    return this._failCall(call, \"RPC_UNKNOWN_METHOD\", \"Unknown method\");\n                }\n                const argsChecker = impl.argsCheckers[call.meth];\n                try {\n                    argsChecker.check(call.args);\n                }\n                catch (e) {\n                    return this._failCall(call, \"RPC_INVALID_ARGS\", `Invalid args: ${e.message}`);\n                }\n            }\n            if (call.reqId === undefined) {\n                return this._failCall(call, \"RPC_MISSING_REQID\", \"Missing request id\");\n            }\n            this._info(call, \"RPC_ONCALL\");\n            let result;\n            try {\n                result = yield impl.invokeImpl(call);\n            }\n            catch (e) {\n                return this._failCall(call, e.code, e.message, \"RPC_ONCALL_ERROR\");\n            }\n            this._info(call, \"RPC_ONCALL_OK\");\n            return this._sendResponse(call.reqId, result);\n        });\n    }\n    _failCall(call, code, mesg, reportCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._warn(call, reportCode || code, mesg);\n            if (call.reqId !== undefined) {\n                const msg = { mtype: message_1.MsgType.RpcRespErr, reqId: call.reqId, mesg, code };\n                yield this._sendMessage(msg);\n            }\n        });\n    }\n    _sendResponse(reqId, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const msg = { mtype: message_1.MsgType.RpcRespData, reqId, data };\n            yield this._sendMessage(msg);\n        });\n    }\n    _onMessageResp(resp) {\n        const callObj = this._pendingCalls.get(resp.reqId);\n        this._pendingCalls.delete(resp.reqId);\n        if (!callObj) {\n            this._warn(null, \"RPC_UNKNOWN_REQID\", `Response to unknown reqId ${resp.reqId}`);\n            return;\n        }\n        if (resp.mtype === message_1.MsgType.RpcRespErr) {\n            this._info(callObj, \"RPC_RESULT_ERROR\", resp.mesg);\n            return callObj.reject(new ErrorWithCode(resp.code, resp.mesg));\n        }\n        try {\n            callObj.resultChecker.check(resp.data);\n        }\n        catch (e) {\n            this._warn(callObj, \"RPC_RESULT_INVALID\", e.message);\n            return callObj.reject(new ErrorWithCode(\"RPC_INVALID_RESULT\", `Implementation produced invalid result: ${e.message}`));\n        }\n        this._info(callObj, \"RPC_RESULT_OK\");\n        callObj.resolve(resp.data);\n    }\n    _info(call, code, message) {\n        if (this._logger.info) {\n            const msg = message ? \" \" + message : \"\";\n            this._logger.info(`Rpc for ${this._callDesc(call)}: ${code}${msg}`);\n        }\n    }\n    _warn(call, code, message) {\n        if (this._logger.warn) {\n            const msg = message ? \" \" + message : \"\";\n            this._logger.warn(`Rpc for ${this._callDesc(call)}: ${code}${msg}`);\n        }\n    }\n    _callDesc(call) {\n        if (!call) {\n            return \"?\";\n        }\n        return `${call.iface}.${call.meth}#${call.reqId || \"-\"}`;\n    }\n    _parseName(name) {\n        const idx = name.lastIndexOf(\"@\");\n        if (idx === -1) {\n            return {\n                forwarder: \"\",\n                name,\n            };\n        }\n        return {\n            name: name.substr(0, idx),\n            forwarder: name.substr(idx + 1),\n        };\n    }\n}\nexports.Rpc = Rpc;\n/**\n * Interfaces may throw errors that include .code field, and it gets propagated to callers (e.g.\n * \"NOT_AUTHORIZED\"). Its purpose is to be a stable way to distinguish different types of errors.\n * This way the human-friendly error message can be changed without affecting behavior.\n */\nclass ErrorWithCode extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorWithCode = ErrorWithCode;\nconst IAnyFunc = tic.iface([], {\n    invoke: tic.func(\"any\"),\n});\nconst { IAnyFunc: checkerAnyFunc } = tic.createCheckers({ IAnyFunc });\nconst checkerAnyResult = checkerAnyFunc.methodResult(\"invoke\");\nconst anyChecker = checkerAnyResult;\n/**\n * A little helper that processes message queues when starting an rpc instance.\n */\nfunction processQueue(queue, processFunc) {\n    let i = 0;\n    try {\n        while (i < queue.length) {\n            // i gets read and then incremented before the call, so that if processFunc throws, the\n            // message still gets removed from the queue (to avoid processing it twice).\n            processFunc(queue[i++]);\n        }\n    }\n    finally {\n        queue.splice(0, i);\n    }\n}\n/**\n * Calls callback(), handling the exception both synchronously and not. If callback and handler\n * both return or throw synchronously, then so does this method.\n */\nfunction catchMaybePromise(callback, handler) {\n    try {\n        const p = callback();\n        if (p) {\n            return p.catch(handler);\n        }\n    }\n    catch (err) {\n        return handler(err);\n    }\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/grain-rpc/dist/lib/rpc.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://grist/./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/ts-interface-checker/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/ts-interface-checker/dist/types.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ts-interface-checker/dist/util.js\");\n/**\n * Export functions used to define interfaces.\n */\nvar types_2 = __webpack_require__(/*! ./types */ \"./node_modules/ts-interface-checker/dist/types.js\");\nexports.TArray = types_2.TArray;\nexports.TEnumType = types_2.TEnumType;\nexports.TEnumLiteral = types_2.TEnumLiteral;\nexports.TFunc = types_2.TFunc;\nexports.TIface = types_2.TIface;\nexports.TLiteral = types_2.TLiteral;\nexports.TName = types_2.TName;\nexports.TOptional = types_2.TOptional;\nexports.TParam = types_2.TParam;\nexports.TParamList = types_2.TParamList;\nexports.TProp = types_2.TProp;\nexports.TTuple = types_2.TTuple;\nexports.TType = types_2.TType;\nexports.TUnion = types_2.TUnion;\nexports.array = types_2.array;\nexports.enumlit = types_2.enumlit;\nexports.enumtype = types_2.enumtype;\nexports.func = types_2.func;\nexports.iface = types_2.iface;\nexports.lit = types_2.lit;\nexports.name = types_2.name;\nexports.opt = types_2.opt;\nexports.param = types_2.param;\nexports.tuple = types_2.tuple;\nexports.union = types_2.union;\nexports.BasicType = types_2.BasicType;\n/**\n * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines\n * them into a suite of interface checkers. If a type is used by name, that name should be present\n * among the passed-in type suites.\n *\n * The returned object maps type names to Checker objects.\n */\nfunction createCheckers(...typeSuite) {\n    const fullSuite = Object.assign({}, types_1.basicTypes, ...typeSuite);\n    const checkers = {};\n    for (const suite of typeSuite) {\n        for (const name of Object.keys(suite)) {\n            checkers[name] = new Checker(fullSuite, suite[name]);\n        }\n    }\n    return checkers;\n}\nexports.createCheckers = createCheckers;\n/**\n * Checker implements validation of objects, and also includes accessors to validate method calls.\n * Checkers should be created using `createCheckers()`.\n */\nclass Checker {\n    // Create checkers by using `createCheckers()` function.\n    constructor(suite, ttype) {\n        this.suite = suite;\n        this.ttype = ttype;\n        this.props = new Map();\n        if (ttype instanceof types_1.TIface) {\n            for (const p of ttype.props) {\n                this.props.set(p.name, p.ttype);\n            }\n        }\n        this.checkerPlain = this.ttype.getChecker(suite, false);\n        this.checkerStrict = this.ttype.getChecker(suite, true);\n    }\n    /**\n     * Check that the given value satisfies this checker's type, or throw Error.\n     */\n    check(value) { return this._doCheck(this.checkerPlain, value); }\n    /**\n     * A fast check for whether or not the given value satisfies this Checker's type. This returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    test(value) {\n        return this.checkerPlain(value, new util_1.NoopContext());\n    }\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type, or null if it does.\n     */\n    validate(value) {\n        return this._doValidate(this.checkerPlain, value);\n    }\n    /**\n     * Check that the given value satisfies this checker's type strictly. This checks that objects\n     * and tuples have no extra members. Note that this prevents backward compatibility, so usually\n     * a plain check() is more appropriate.\n     */\n    strictCheck(value) { return this._doCheck(this.checkerStrict, value); }\n    /**\n     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    strictTest(value) {\n        return this.checkerStrict(value, new util_1.NoopContext());\n    }\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type strictly, or null if it does.\n     */\n    strictValidate(value) {\n        return this._doValidate(this.checkerStrict, value);\n    }\n    /**\n     * If this checker is for an interface, returns a Checker for the type required for the given\n     * property of this interface.\n     */\n    getProp(prop) {\n        const ttype = this.props.get(prop);\n        if (!ttype) {\n            throw new Error(`Type has no property ${prop}`);\n        }\n        return new Checker(this.suite, ttype);\n    }\n    /**\n     * If this checker is for an interface, returns a Checker for the argument-list required to call\n     * the given method of this interface. E.g. if this Checker is for the interface:\n     *    interface Foo {\n     *      find(s: string, pos?: number): number;\n     *    }\n     * Then methodArgs(\"find\").check(...) will succeed for [\"foo\"] and [\"foo\", 3], but not for [17].\n     */\n    methodArgs(methodName) {\n        const tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.paramList);\n    }\n    /**\n     * If this checker is for an interface, returns a Checker for the return value of the given\n     * method of this interface.\n     */\n    methodResult(methodName) {\n        const tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.result);\n    }\n    /**\n     * If this checker is for a function, returns a Checker for its argument-list.\n     */\n    getArgs() {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getArgs() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.paramList);\n    }\n    /**\n     * If this checker is for a function, returns a Checker for its result.\n     */\n    getResult() {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getResult() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.result);\n    }\n    /**\n     * Return the type for which this is a checker.\n     */\n    getType() {\n        return this.ttype;\n    }\n    /**\n     * Actual implementation of check() and strictCheck().\n     */\n    _doCheck(checkerFunc, value) {\n        const noopCtx = new util_1.NoopContext();\n        if (!checkerFunc(value, noopCtx)) {\n            const detailCtx = new util_1.DetailContext();\n            checkerFunc(value, detailCtx);\n            throw detailCtx.getError();\n        }\n    }\n    _doValidate(checkerFunc, value) {\n        const noopCtx = new util_1.NoopContext();\n        if (checkerFunc(value, noopCtx)) {\n            return null;\n        }\n        const detailCtx = new util_1.DetailContext();\n        checkerFunc(value, detailCtx);\n        return detailCtx.getErrorDetail();\n    }\n    _getMethod(methodName) {\n        const ttype = this.props.get(methodName);\n        if (!ttype) {\n            throw new Error(`Type has no property ${methodName}`);\n        }\n        if (!(ttype instanceof types_1.TFunc)) {\n            throw new Error(`Property ${methodName} is not a method`);\n        }\n        return ttype;\n    }\n}\nexports.Checker = Checker;\n\n\n//# sourceURL=webpack://grist/./node_modules/ts-interface-checker/dist/index.js?");

/***/ }),

/***/ "./node_modules/ts-interface-checker/dist/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/types.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n/**\n * This module defines nodes used to define types and validations for objects and interfaces.\n */\n// tslint:disable:no-shadowed-variable prefer-for-of\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ts-interface-checker/dist/util.js\");\n/** Node that represents a type. */\nclass TType {\n}\nexports.TType = TType;\n/** Parses a type spec into a TType node. */\nfunction parseSpec(typeSpec) {\n    return typeof typeSpec === \"string\" ? name(typeSpec) : typeSpec;\n}\nfunction getNamedType(suite, name) {\n    const ttype = suite[name];\n    if (!ttype) {\n        throw new Error(`Unknown type ${name}`);\n    }\n    return ttype;\n}\n/**\n * Defines a type name, either built-in, or defined in this suite. It can typically be included in\n * the specs as just a plain string.\n */\nfunction name(value) { return new TName(value); }\nexports.name = name;\nclass TName extends TType {\n    constructor(name) {\n        super();\n        this.name = name;\n        this._failMsg = `is not a ${name}`;\n    }\n    getChecker(suite, strict) {\n        const ttype = getNamedType(suite, this.name);\n        const checker = ttype.getChecker(suite, strict);\n        if (ttype instanceof BasicType || ttype instanceof TName) {\n            return checker;\n        }\n        // For complex types, add an additional \"is not a <Type>\" message on failure.\n        return (value, ctx) => checker(value, ctx) ? true : ctx.fail(null, this._failMsg, 0);\n    }\n}\nexports.TName = TName;\n/**\n * Defines a literal value, e.g. lit('hello') or lit(123).\n */\nfunction lit(value) { return new TLiteral(value); }\nexports.lit = lit;\nclass TLiteral extends TType {\n    constructor(value) {\n        super();\n        this.value = value;\n        this.name = JSON.stringify(value);\n        this._failMsg = `is not ${this.name}`;\n    }\n    getChecker(suite, strict) {\n        return (value, ctx) => (value === this.value) ? true : ctx.fail(null, this._failMsg, -1);\n    }\n}\nexports.TLiteral = TLiteral;\n/**\n * Defines an array type, e.g. array('number').\n */\nfunction array(typeSpec) { return new TArray(parseSpec(typeSpec)); }\nexports.array = array;\nclass TArray extends TType {\n    constructor(ttype) {\n        super();\n        this.ttype = ttype;\n    }\n    getChecker(suite, strict) {\n        const itemChecker = this.ttype.getChecker(suite, strict);\n        return (value, ctx) => {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (let i = 0; i < value.length; i++) {\n                const ok = itemChecker(value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    }\n}\nexports.TArray = TArray;\n/**\n * Defines a tuple type, e.g. tuple('string', 'number').\n */\nfunction tuple(...typeSpec) {\n    return new TTuple(typeSpec.map((t) => parseSpec(t)));\n}\nexports.tuple = tuple;\nclass TTuple extends TType {\n    constructor(ttypes) {\n        super();\n        this.ttypes = ttypes;\n    }\n    getChecker(suite, strict) {\n        const itemCheckers = this.ttypes.map((t) => t.getChecker(suite, strict));\n        const checker = (value, ctx) => {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (let i = 0; i < itemCheckers.length; i++) {\n                const ok = itemCheckers[i](value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return (value, ctx) => {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    }\n}\nexports.TTuple = TTuple;\n/**\n * Defines a union type, e.g. union('number', 'null').\n */\nfunction union(...typeSpec) {\n    return new TUnion(typeSpec.map((t) => parseSpec(t)));\n}\nexports.union = union;\nclass TUnion extends TType {\n    constructor(ttypes) {\n        super();\n        this.ttypes = ttypes;\n        const names = ttypes.map((t) => t instanceof TName || t instanceof TLiteral ? t.name : null)\n            .filter((n) => n);\n        const otherTypes = ttypes.length - names.length;\n        if (names.length) {\n            if (otherTypes > 0) {\n                names.push(`${otherTypes} more`);\n            }\n            this._failMsg = `is none of ${names.join(\", \")}`;\n        }\n        else {\n            this._failMsg = `is none of ${otherTypes} types`;\n        }\n    }\n    getChecker(suite, strict) {\n        const itemCheckers = this.ttypes.map((t) => t.getChecker(suite, strict));\n        return (value, ctx) => {\n            const ur = ctx.unionResolver();\n            for (let i = 0; i < itemCheckers.length; i++) {\n                const ok = itemCheckers[i](value, ur.createContext());\n                if (ok) {\n                    return true;\n                }\n            }\n            ctx.resolveUnion(ur);\n            return ctx.fail(null, this._failMsg, 0);\n        };\n    }\n}\nexports.TUnion = TUnion;\n/**\n * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).\n */\nfunction enumtype(values) {\n    return new TEnumType(values);\n}\nexports.enumtype = enumtype;\nclass TEnumType extends TType {\n    constructor(members) {\n        super();\n        this.members = members;\n        this.validValues = new Set();\n        this._failMsg = \"is not a valid enum value\";\n        this.validValues = new Set(Object.keys(members).map((name) => members[name]));\n    }\n    getChecker(suite, strict) {\n        return (value, ctx) => (this.validValues.has(value) ? true : ctx.fail(null, this._failMsg, 0));\n    }\n}\nexports.TEnumType = TEnumType;\n/**\n * Defines a literal enum value, such as Direction.Up, specified as enumlit(\"Direction\", \"Up\").\n */\nfunction enumlit(name, prop) {\n    return new TEnumLiteral(name, prop);\n}\nexports.enumlit = enumlit;\nclass TEnumLiteral extends TType {\n    constructor(enumName, prop) {\n        super();\n        this.enumName = enumName;\n        this.prop = prop;\n        this._failMsg = `is not ${enumName}.${prop}`;\n    }\n    getChecker(suite, strict) {\n        const ttype = getNamedType(suite, this.enumName);\n        if (!(ttype instanceof TEnumType)) {\n            throw new Error(`Type ${this.enumName} used in enumlit is not an enum type`);\n        }\n        const val = ttype.members[this.prop];\n        if (!ttype.members.hasOwnProperty(this.prop)) {\n            throw new Error(`Unknown value ${this.enumName}.${this.prop} used in enumlit`);\n        }\n        return (value, ctx) => (value === val) ? true : ctx.fail(null, this._failMsg, -1);\n    }\n}\nexports.TEnumLiteral = TEnumLiteral;\nfunction makeIfaceProps(props) {\n    return Object.keys(props).map((name) => makeIfaceProp(name, props[name]));\n}\nfunction makeIfaceProp(name, prop) {\n    return prop instanceof TOptional ?\n        new TProp(name, prop.ttype, true) :\n        new TProp(name, parseSpec(prop), false);\n}\n/**\n * Defines an interface. The first argument is an array of interfaces that it extends, and the\n * second is an array of properties.\n */\nfunction iface(bases, props) {\n    return new TIface(bases, makeIfaceProps(props));\n}\nexports.iface = iface;\nclass TIface extends TType {\n    constructor(bases, props) {\n        super();\n        this.bases = bases;\n        this.props = props;\n        this.propSet = new Set(props.map((p) => p.name));\n    }\n    getChecker(suite, strict) {\n        const baseCheckers = this.bases.map((b) => getNamedType(suite, b).getChecker(suite, strict));\n        const propCheckers = this.props.map((prop) => prop.ttype.getChecker(suite, strict));\n        const testCtx = new util_1.NoopContext();\n        // Consider a prop required if it's not optional AND does not allow for undefined as a value.\n        const isPropRequired = this.props.map((prop, i) => !prop.isOpt && !propCheckers[i](undefined, testCtx));\n        const checker = (value, ctx) => {\n            if (typeof value !== \"object\" || value === null) {\n                return ctx.fail(null, \"is not an object\", 0);\n            }\n            for (let i = 0; i < baseCheckers.length; i++) {\n                if (!baseCheckers[i](value, ctx)) {\n                    return false;\n                }\n            }\n            for (let i = 0; i < propCheckers.length; i++) {\n                const name = this.props[i].name;\n                const v = value[name];\n                if (v === undefined) {\n                    if (isPropRequired[i]) {\n                        return ctx.fail(name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    const ok = propCheckers[i](v, ctx);\n                    if (!ok) {\n                        return ctx.fail(name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        // In strict mode, check also for unknown enumerable properties.\n        return (value, ctx) => {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            for (const prop in value) {\n                if (!this.propSet.has(prop)) {\n                    return ctx.fail(prop, \"is extraneous\", 2);\n                }\n            }\n            return true;\n        };\n    }\n}\nexports.TIface = TIface;\n/**\n * Defines an optional property on an interface.\n */\nfunction opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }\nexports.opt = opt;\nclass TOptional {\n    constructor(ttype) {\n        this.ttype = ttype;\n    }\n}\nexports.TOptional = TOptional;\n/**\n * Defines a property in an interface.\n */\nclass TProp {\n    constructor(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n}\nexports.TProp = TProp;\n/**\n * Defines a function. The first argument declares the function's return type, the rest declare\n * its parameters.\n */\nfunction func(resultSpec, ...params) {\n    return new TFunc(new TParamList(params), parseSpec(resultSpec));\n}\nexports.func = func;\nclass TFunc extends TType {\n    constructor(paramList, result) {\n        super();\n        this.paramList = paramList;\n        this.result = result;\n    }\n    getChecker(suite, strict) {\n        return (value, ctx) => {\n            return typeof value === \"function\" ? true : ctx.fail(null, \"is not a function\", 0);\n        };\n    }\n}\nexports.TFunc = TFunc;\n/**\n * Defines a function parameter.\n */\nfunction param(name, typeSpec, isOpt) {\n    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));\n}\nexports.param = param;\nclass TParam {\n    constructor(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n}\nexports.TParam = TParam;\n/**\n * Defines a function parameter list.\n */\nclass TParamList extends TType {\n    constructor(params) {\n        super();\n        this.params = params;\n    }\n    getChecker(suite, strict) {\n        const itemCheckers = this.params.map((t) => t.ttype.getChecker(suite, strict));\n        const testCtx = new util_1.NoopContext();\n        const isParamRequired = this.params.map((param, i) => !param.isOpt && !itemCheckers[i](undefined, testCtx));\n        const checker = (value, ctx) => {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (let i = 0; i < itemCheckers.length; i++) {\n                const p = this.params[i];\n                if (value[i] === undefined) {\n                    if (isParamRequired[i]) {\n                        return ctx.fail(p.name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    const ok = itemCheckers[i](value[i], ctx);\n                    if (!ok) {\n                        return ctx.fail(p.name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return (value, ctx) => {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    }\n}\nexports.TParamList = TParamList;\n/**\n * Single TType implementation for all basic built-in types.\n */\nclass BasicType extends TType {\n    constructor(validator, message) {\n        super();\n        this.validator = validator;\n        this.message = message;\n    }\n    getChecker(suite, strict) {\n        return (value, ctx) => this.validator(value) ? true : ctx.fail(null, this.message, 0);\n    }\n}\nexports.BasicType = BasicType;\n/**\n * Defines the suite of basic types.\n */\nexports.basicTypes = {\n    any: new BasicType((v) => true, \"is invalid\"),\n    number: new BasicType((v) => (typeof v === \"number\"), \"is not a number\"),\n    object: new BasicType((v) => (typeof v === \"object\" && v), \"is not an object\"),\n    boolean: new BasicType((v) => (typeof v === \"boolean\"), \"is not a boolean\"),\n    string: new BasicType((v) => (typeof v === \"string\"), \"is not a string\"),\n    symbol: new BasicType((v) => (typeof v === \"symbol\"), \"is not a symbol\"),\n    void: new BasicType((v) => (v == null), \"is not void\"),\n    undefined: new BasicType((v) => (v === undefined), \"is not undefined\"),\n    null: new BasicType((v) => (v === null), \"is not null\"),\n    never: new BasicType((v) => false, \"is unexpected\"),\n};\nif (typeof Buffer !== \"undefined\") {\n    exports.basicTypes.Buffer = new BasicType((v) => Buffer.isBuffer(v), \"is not a Buffer\");\n}\n// Support typed arrays of various flavors\nfor (const array of [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]) {\n    exports.basicTypes[array.name] = new BasicType((v) => (v instanceof array), `is not a ${array.name}`);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://grist/./node_modules/ts-interface-checker/dist/types.js?");

/***/ }),

/***/ "./node_modules/ts-interface-checker/dist/util.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Error thrown by validation. Besides an informative message, it includes the path to the\n * property which triggered the failure.\n */\nclass VError extends Error {\n    constructor(path, message) {\n        super(message);\n        this.path = path;\n    }\n}\nexports.VError = VError;\n/**\n * Fast implementation of IContext used for first-pass validation. If that fails, we can validate\n * using DetailContext to collect error messages. That's faster for the common case when messages\n * normally pass validation.\n */\nclass NoopContext {\n    fail(relPath, message, score) {\n        return false;\n    }\n    unionResolver() { return this; }\n    createContext() { return this; }\n    resolveUnion(ur) { }\n}\nexports.NoopContext = NoopContext;\n/**\n * Complete implementation of IContext that collects meaningfull errors.\n */\nclass DetailContext {\n    constructor() {\n        // Stack of property names and associated messages for reporting helpful error messages.\n        this._propNames = [\"\"];\n        this._messages = [null];\n        // Score is used to choose the best union member whose DetailContext to use for reporting.\n        // Higher score means better match (or rather less severe mismatch).\n        this._score = 0;\n    }\n    fail(relPath, message, score) {\n        this._propNames.push(relPath);\n        this._messages.push(message);\n        this._score += score;\n        return false;\n    }\n    unionResolver() {\n        return new DetailUnionResolver();\n    }\n    resolveUnion(unionResolver) {\n        const u = unionResolver;\n        let best = null;\n        for (const ctx of u.contexts) {\n            if (!best || ctx._score >= best._score) {\n                best = ctx;\n            }\n        }\n        if (best && best._score > 0) {\n            this._propNames.push(...best._propNames);\n            this._messages.push(...best._messages);\n        }\n    }\n    getError() {\n        let path = \"value\";\n        const msgParts = [];\n        for (let i = this._propNames.length - 1; i >= 0; i--) {\n            const p = this._propNames[i];\n            path += (typeof p === \"number\") ? `[${p}]` : (p ? `.${p}` : \"\");\n            const m = this._messages[i];\n            if (m) {\n                msgParts.push(`${path} ${m}`);\n            }\n        }\n        return new VError(path, msgParts.join(\"; \"));\n    }\n    getErrorDetail() {\n        let path = \"value\";\n        const details = [];\n        for (let i = this._propNames.length - 1; i >= 0; i--) {\n            const p = this._propNames[i];\n            path += (typeof p === \"number\") ? `[${p}]` : (p ? `.${p}` : \"\");\n            const message = this._messages[i];\n            if (message) {\n                details.push({ path, message });\n            }\n        }\n        let detail = null;\n        for (let i = details.length - 1; i >= 0; i--) {\n            if (detail) {\n                details[i].nested = [detail];\n            }\n            detail = details[i];\n        }\n        return detail;\n    }\n}\nexports.DetailContext = DetailContext;\nclass DetailUnionResolver {\n    constructor() {\n        this.contexts = [];\n    }\n    createContext() {\n        const ctx = new DetailContext();\n        this.contexts.push(ctx);\n        return ctx;\n    }\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/ts-interface-checker/dist/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://grist/(webpack)/buildin/global.js?");

/***/ })

/******/ });